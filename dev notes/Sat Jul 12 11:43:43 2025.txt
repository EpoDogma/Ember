Alright, so I was first inspired to do this from a video I saw on youtube: Let's Create a Compiler (Pt.1) by Pixeled.
After watching about half of the first video, I decided that I could give it a try. I had wanted something to
practice my programming skills with again anyway. However, finding online resources that are beginner friendly on 
the process of making a compiler and why you segregate each part of it was a much harder task than I had anticipated.

Along with Pixeled's videos, I have found that briefly scanning through Nora Sandler's Writing a C Compiler, Part 1 (https://norasandler.com/2017/11/29/Write-a-Compiler.html) was much more helpful than the hour+ I spent looking for other sources-- most which referenced $50-$200 books, or did not cover the kind of depth I needed.

Now, on to my progress up to this point and my tentative roadmap.

I have finished implementing a VERY basic tokenizer (lexer) that is capable of accepting explicit keywords-- the only one currently defined being return--, any combination of unsigned digits that are continguous, semicolons, spaces, and newlines. This tokenizer is flimsy and has functionally no robustness built into it. This definitely took much longer than it needed to and had a lot refactoring and troubleshooting to attempt to set myself up for easier expansion on it's functionalities later on.

I then implemented a very basic translator (really an awkward term that doesn't fit) to translate the tokenized program into assembly. Since the only functionality of my program currently is to return an integer literal, the "translator" just substitutes the integer literal and follows a template I laid out for it. Of course, this is also a flimsy design with no robustness built into it.

I then briefly created a simple implementation of a makefile in cpp (for no reason other than practice-- because it really has been that long for
me since I have coded at all (okay it's been like 6 months but still)) to automate compilation, assemblage, and linking to produce an executable.

My next steps are to:
 - Implement test cases
 - Extend tokenizing (lexing) to include more, such as:
    - Open/Close parenthesis (for conditions)
    - Open/Close Braces (for bodies)
    - Addition
    - Subtraction
    - Equation (=)
    - Basic alphabetical variables
 - Develop a Parser following an Abstract Syntax Tree (AST)
 - Fortify (and eventually harden) code
 - Extend code generation functionality

Also, these are other sources that I additionally found helpful:
 - https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/
 - https://math.hws.edu/eck/cs220/f22/registers.html
 - https://godbolt.org/